-- ================================================================
-- Grok Imagine Expert - Database Schema
-- ================================================================
-- Platform: Supabase (PostgreSQL)
-- Purpose: Store metadata for tree-based video exploration with MCTS
-- Note: Media files (images/videos) stored in Dropbox
-- ================================================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ================================================================
-- Table 1: projects
-- Purpose: Top-level project organization
-- ================================================================
CREATE TABLE IF NOT EXISTS projects (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    dropbox_path TEXT NOT NULL,  -- Relative path under ~/Dropbox/grok-imagine-expert/
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for listing projects
CREATE INDEX IF NOT EXISTS idx_projects_created ON projects(created_at DESC);

-- ================================================================
-- Table 2: passes
-- Purpose: Exploration passes (each pass = one tree from one initial image)
-- ================================================================
CREATE TABLE IF NOT EXISTS passes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    initial_image_path TEXT NOT NULL,  -- Dropbox relative path
    base_prompt TEXT,                   -- Base prompt for video generation
    mode TEXT DEFAULT 'manual' CHECK (mode IN ('manual', 'auto')),

    -- MCTS configuration (for auto mode)
    mcts_config JSONB DEFAULT '{
        "iterations": 100,
        "exploration_constant": 1.414,
        "max_children": 3,
        "max_depth": 10,
        "simulation_depth": 3
    }'::jsonb,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_passes_project ON passes(project_id);
CREATE INDEX IF NOT EXISTS idx_passes_created ON passes(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_passes_mode ON passes(mode);

-- ================================================================
-- Table 3: nodes (CORE TABLE)
-- Purpose: Tree nodes with MCTS statistics
-- ================================================================
CREATE TABLE IF NOT EXISTS nodes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    pass_id UUID NOT NULL REFERENCES passes(id) ON DELETE CASCADE,
    node_type TEXT NOT NULL CHECK (node_type IN ('image', 'video')),
    file_path TEXT NOT NULL,  -- Dropbox relative path
    parent_id UUID REFERENCES nodes(id) ON DELETE SET NULL,
    depth INTEGER DEFAULT 0 CHECK (depth >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- ============================================================
    -- MCTS Core Fields
    -- ============================================================
    visit_count INTEGER DEFAULT 0 CHECK (visit_count >= 0),
    total_reward REAL DEFAULT 0.0,
    avg_reward REAL DEFAULT 0.0,

    -- MCTS-specific (vs simple UCB)
    is_fully_expanded BOOLEAN DEFAULT FALSE,
    is_terminal BOOLEAN DEFAULT FALSE,

    -- UCB calculation
    ucb_score REAL,
    last_selected_at TIMESTAMPTZ,

    -- ============================================================
    -- Multi-dimensional Scoring (0-1 range)
    -- ============================================================
    quality_score REAL CHECK (quality_score IS NULL OR (quality_score >= 0 AND quality_score <= 1)),
    coherence_score REAL CHECK (coherence_score IS NULL OR (coherence_score >= 0 AND coherence_score <= 1)),
    diversity_score REAL CHECK (diversity_score IS NULL OR (diversity_score >= 0 AND diversity_score <= 1)),
    semantic_score REAL CHECK (semantic_score IS NULL OR (semantic_score >= 0 AND semantic_score <= 1)),

    -- ============================================================
    -- Auxiliary Fields
    -- ============================================================
    user_selected BOOLEAN DEFAULT FALSE,          -- Manually selected by user
    auto_generated BOOLEAN DEFAULT FALSE,         -- Generated by MCTS auto mode
    generation_strategy TEXT CHECK (
        generation_strategy IS NULL OR
        generation_strategy IN ('exploit', 'explore', 'manual')
    ),

    -- ============================================================
    -- Extensibility
    -- ============================================================
    metadata JSONB DEFAULT '{}'::jsonb  -- Flexible storage for:
                                         -- - generation_params
                                         -- - prompt_variations
                                         -- - error_logs
                                         -- - custom_tags
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_nodes_pass ON nodes(pass_id);
CREATE INDEX IF NOT EXISTS idx_nodes_parent ON nodes(parent_id);
CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(node_type);
CREATE INDEX IF NOT EXISTS idx_nodes_depth ON nodes(depth);

-- MCTS query optimization
CREATE INDEX IF NOT EXISTS idx_nodes_ucb ON nodes(ucb_score DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS idx_nodes_visit ON nodes(visit_count);
CREATE INDEX IF NOT EXISTS idx_nodes_avg_reward ON nodes(avg_reward DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS idx_nodes_expanded ON nodes(is_fully_expanded) WHERE NOT is_fully_expanded;

-- User interaction queries
CREATE INDEX IF NOT EXISTS idx_nodes_user_selected ON nodes(user_selected) WHERE user_selected;
CREATE INDEX IF NOT EXISTS idx_nodes_auto_generated ON nodes(auto_generated) WHERE auto_generated;

-- ================================================================
-- Table 4: generations
-- Purpose: Async video generation task queue
-- ================================================================
CREATE TABLE IF NOT EXISTS generations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    node_id UUID NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed')),
    candidate_count INTEGER DEFAULT 5 CHECK (candidate_count > 0),

    -- Results (populated after completion)
    candidate_paths JSONB,  -- Array of {path: "...", temp_score: 0.8}

    -- Error handling
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
);

-- Indexes for task queue management
CREATE INDEX IF NOT EXISTS idx_generations_status ON generations(status);
CREATE INDEX IF NOT EXISTS idx_generations_node ON generations(node_id);
CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at);
CREATE INDEX IF NOT EXISTS idx_generations_pending ON generations(created_at) WHERE status = 'pending';

-- ================================================================
-- Table 5: mcts_simulations (OPTIONAL - for analysis/debugging)
-- Purpose: Record each MCTS iteration for analysis
-- ================================================================
CREATE TABLE IF NOT EXISTS mcts_simulations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    pass_id UUID NOT NULL REFERENCES passes(id) ON DELETE CASCADE,
    iteration INTEGER NOT NULL CHECK (iteration > 0),

    -- MCTS phase outcomes
    selected_node_id UUID REFERENCES nodes(id),
    expanded_node_id UUID REFERENCES nodes(id),
    simulation_reward REAL,

    -- Path taken during selection
    selection_path UUID[],  -- Array of node IDs from root to leaf

    -- UCB values at decision points
    ucb_values JSONB,  -- {node_id: ucb_score, ...}

    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for MCTS analysis
CREATE INDEX IF NOT EXISTS idx_mcts_pass ON mcts_simulations(pass_id);
CREATE INDEX IF NOT EXISTS idx_mcts_iteration ON mcts_simulations(pass_id, iteration);

-- ================================================================
-- Helper Functions
-- ================================================================

-- Function: Calculate UCB score for a node
CREATE OR REPLACE FUNCTION calculate_ucb(
    node_id UUID,
    exploration_constant REAL DEFAULT 1.414
)
RETURNS REAL AS $$
DECLARE
    node RECORD;
    parent_visits INTEGER;
    exploitation REAL;
    exploration REAL;
BEGIN
    -- Get node data
    SELECT visit_count, avg_reward, parent_id INTO node
    FROM nodes WHERE id = node_id;

    -- If never visited, return infinity (high priority)
    IF node.visit_count = 0 THEN
        RETURN 'Infinity'::REAL;
    END IF;

    -- Get parent's visit count
    IF node.parent_id IS NULL THEN
        -- Root node
        RETURN node.avg_reward;
    END IF;

    SELECT visit_count INTO parent_visits
    FROM nodes WHERE id = node.parent_id;

    IF parent_visits = 0 THEN
        RETURN node.avg_reward;
    END IF;

    -- UCB1 formula: avg_reward + c * sqrt(ln(parent_visits) / visit_count)
    exploitation := node.avg_reward;
    exploration := exploration_constant * SQRT(LN(parent_visits) / node.visit_count);

    RETURN exploitation + exploration;
END;
$$ LANGUAGE plpgsql;

-- Function: Get all leaf nodes in a pass (for MCTS selection)
CREATE OR REPLACE FUNCTION get_leaf_nodes(pass_uuid UUID)
RETURNS TABLE(
    node_id UUID,
    node_type TEXT,
    depth INTEGER,
    visit_count INTEGER,
    avg_reward REAL,
    ucb_score REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        n.id,
        n.node_type,
        n.depth,
        n.visit_count,
        n.avg_reward,
        n.ucb_score
    FROM nodes n
    WHERE n.pass_id = pass_uuid
      AND n.node_type = 'image'  -- Only image nodes can be expanded
      AND NOT EXISTS (
          SELECT 1 FROM nodes child
          WHERE child.parent_id = n.id
      )
    ORDER BY n.ucb_score DESC NULLS LAST;
END;
$$ LANGUAGE plpgsql;

-- Function: Get path from node to root
CREATE OR REPLACE FUNCTION get_path_to_root(node_uuid UUID)
RETURNS UUID[] AS $$
DECLARE
    path UUID[] := ARRAY[]::UUID[];
    current_id UUID := node_uuid;
    parent_id UUID;
BEGIN
    WHILE current_id IS NOT NULL LOOP
        path := array_append(path, current_id);

        SELECT n.parent_id INTO parent_id
        FROM nodes n WHERE n.id = current_id;

        current_id := parent_id;
    END LOOP;

    RETURN path;
END;
$$ LANGUAGE plpgsql;

-- Function: Get best path (highest avg_reward) from root to any leaf
CREATE OR REPLACE FUNCTION get_best_path(pass_uuid UUID)
RETURNS TABLE(
    path UUID[],
    total_depth INTEGER,
    path_avg_reward REAL,
    leaf_node_id UUID
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE leaf_nodes AS (
        -- Find all leaf image nodes
        SELECT
            n.id,
            n.pass_id,
            n.depth,
            n.avg_reward
        FROM nodes n
        WHERE n.pass_id = pass_uuid
          AND n.node_type = 'image'
          AND NOT EXISTS (
              SELECT 1 FROM nodes child WHERE child.parent_id = n.id
          )
    ),
    best_leaf AS (
        SELECT id, depth, avg_reward
        FROM leaf_nodes
        ORDER BY avg_reward DESC NULLS LAST
        LIMIT 1
    )
    SELECT
        get_path_to_root(best_leaf.id) as path,
        best_leaf.depth as total_depth,
        best_leaf.avg_reward as path_avg_reward,
        best_leaf.id as leaf_node_id
    FROM best_leaf;
END;
$$ LANGUAGE plpgsql;

-- ================================================================
-- Triggers
-- ================================================================

-- Trigger: Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER projects_updated_at
    BEFORE UPDATE ON projects
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER passes_updated_at
    BEFORE UPDATE ON passes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();

-- Trigger: Auto-calculate avg_reward when total_reward or visit_count changes
CREATE OR REPLACE FUNCTION calculate_avg_reward()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.visit_count > 0 THEN
        NEW.avg_reward := NEW.total_reward / NEW.visit_count;
    ELSE
        NEW.avg_reward := 0;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER nodes_avg_reward
    BEFORE INSERT OR UPDATE OF total_reward, visit_count ON nodes
    FOR EACH ROW
    EXECUTE FUNCTION calculate_avg_reward();

-- ================================================================
-- Views (for convenience)
-- ================================================================

-- View: Project summary with pass counts
CREATE OR REPLACE VIEW project_summary AS
SELECT
    p.id,
    p.name,
    p.description,
    p.created_at,
    COUNT(DISTINCT ps.id) as pass_count,
    COUNT(DISTINCT n.id) as total_nodes,
    SUM(CASE WHEN ps.mode = 'auto' THEN 1 ELSE 0 END) as auto_passes,
    SUM(CASE WHEN ps.mode = 'manual' THEN 1 ELSE 0 END) as manual_passes
FROM projects p
LEFT JOIN passes ps ON ps.project_id = p.id
LEFT JOIN nodes n ON n.pass_id = ps.id
GROUP BY p.id, p.name, p.description, p.created_at;

-- View: Pass summary with node statistics
CREATE OR REPLACE VIEW pass_summary AS
SELECT
    ps.id,
    ps.project_id,
    ps.mode,
    ps.created_at,
    COUNT(DISTINCT n.id) as node_count,
    COUNT(DISTINCT CASE WHEN n.node_type = 'image' THEN n.id END) as image_count,
    COUNT(DISTINCT CASE WHEN n.node_type = 'video' THEN n.id END) as video_count,
    MAX(n.depth) as max_depth,
    AVG(n.avg_reward) as avg_tree_reward,
    SUM(n.visit_count) as total_visits
FROM passes ps
LEFT JOIN nodes n ON n.pass_id = ps.id
GROUP BY ps.id, ps.project_id, ps.mode, ps.created_at;

-- ================================================================
-- Sample Data (for testing)
-- ================================================================

-- Uncomment to insert sample data:
/*
-- Sample project
INSERT INTO projects (id, name, description, dropbox_path)
VALUES (
    '00000000-0000-0000-0000-000000000001',
    'Test Project',
    'Sample project for testing',
    'projects/test-project-001'
);

-- Sample pass
INSERT INTO passes (id, project_id, initial_image_path, base_prompt, mode)
VALUES (
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000001',
    'projects/test-project-001/passes/pass-001/images/img-root.jpg',
    'A serene landscape with mountains',
    'manual'
);

-- Sample root image node
INSERT INTO nodes (id, pass_id, node_type, file_path, parent_id, depth)
VALUES (
    '00000000-0000-0000-0000-000000000003',
    '00000000-0000-0000-0000-000000000002',
    'image',
    'projects/test-project-001/passes/pass-001/images/img-root.jpg',
    NULL,
    0
);
*/

-- ================================================================
-- Cleanup (for development - DANGEROUS in production!)
-- ================================================================

-- Uncomment to reset all data:
/*
DROP VIEW IF EXISTS project_summary CASCADE;
DROP VIEW IF EXISTS pass_summary CASCADE;
DROP TABLE IF EXISTS mcts_simulations CASCADE;
DROP TABLE IF EXISTS generations CASCADE;
DROP TABLE IF EXISTS nodes CASCADE;
DROP TABLE IF EXISTS passes CASCADE;
DROP TABLE IF EXISTS projects CASCADE;
DROP FUNCTION IF EXISTS calculate_ucb CASCADE;
DROP FUNCTION IF EXISTS get_leaf_nodes CASCADE;
DROP FUNCTION IF EXISTS get_path_to_root CASCADE;
DROP FUNCTION IF EXISTS get_best_path CASCADE;
DROP FUNCTION IF EXISTS update_updated_at CASCADE;
DROP FUNCTION IF EXISTS calculate_avg_reward CASCADE;
*/

-- ================================================================
-- End of Schema
-- ================================================================
